! Calculate Nuclear Repulsion
subroutine calcnure(nure)
use util
use defvar
implicit real*8 (a-h,o-z)
integer atmarr(ncenter)
real*8 nure
real*8 inertia(3,3),eigvalint(3),eigvecmatint(3,3)
natmarr=ncenter
!allocate(atmarr(natmarr))
do itmp=1,natmarr
   atmarr(itmp)=itmp
end do
totmass=sum(atmwei(a(atmarr(:))%index))
avgx=sum(a(atmarr(:))%x)/natmarr
avgy=sum(a(atmarr(:))%y)/natmarr
avgz=sum(a(atmarr(:))%z)/natmarr
cenmassx=sum(a(atmarr(:))%x*atmwei(a(atmarr(:))%index))/totmass
cenmassy=sum(a(atmarr(:))%y*atmwei(a(atmarr(:))%index))/totmass
cenmassz=sum(a(atmarr(:))%z*atmwei(a(atmarr(:))%index))/totmass
rgyr=dsqrt( sum( atmwei(a(atmarr(:))%index)* ((a(atmarr(:))%x-cenmassx)**2+(a(atmarr(:))%y-cenmassy)**2+(a(atmarr(:))%z-cenmassz)**2) ) / totmass )
totnucchg=sum(a(atmarr(:))%charge)
dipnucx=sum(a(atmarr(:))%x*a(atmarr(:))%charge)
dipnucy=sum(a(atmarr(:))%y*a(atmarr(:))%charge)
dipnucz=sum(a(atmarr(:))%z*a(atmarr(:))%charge)
dipnucnorm=dsqrt(dipnucx**2+dipnucy**2+dipnucz**2)
nure=0D0
do iatmidx=1,natmarr
    iatm=atmarr(iatmidx)
    do jatmidx=iatmidx+1,natmarr
        jatm=atmarr(jatmidx)
        nure=nure+a(iatm)%charge*a(jatm)%charge/distmat(iatm,jatm)
    end do
end do

end subroutine

!!---------- Update the number of electrons
subroutine updatenelec
use defvar
integer imo
nelec=0
naelec=0
nbelec=0
do imo=1,nmo
    if (MOtype(imo)==0) then
        naelec=naelec+MOocc(imo)/2D0
        nbelec=nbelec+MOocc(imo)/2D0
    else if (MOtype(imo)==1) then
        naelec=naelec+MOocc(imo)
    else if (MOtype(imo)==2) then
        nbelec=nbelec+MOocc(imo)
    end if
end do
nelec=naelec+nbelec
end subroutine
            
!!!---------- Return normalization coefficient for specific type of spherical harmonic GTF
!See http://en.wikipedia.org/wiki/Gaussian_orbital for the formula
!!!This is useless for resolving the contraction coefficent problem of Molden input file of ORCA , I don't know why
!Lval is the angular moment, 0/1/2/3/4=s/p/d/f/g
! real*8 function rnormgau_sph(Lval,exp)
! use defvar
! use util
! integer Lval
! real*8 exp
! rnormgau_sph=exp**(Lval/2D0+0.75D0) / (dsqrt(pi)*2**(-0.25D0-Lval/2D0)) / dsqrt(gamma_ps(Lval+1))
! end function
subroutine genn1n2nf(Lval,n1,n2,nf)
integer Lval,n1,n2,nf
if (Lval==0) then
    n1=3
    n2=3
    nf=1
else if (Lval==1) then
    n1=7
    n2=5
    nf=1
else if (Lval==2) then
    n1=11
    n2=7
    nf=9
else if (Lval==3) then
    n1=15
    n2=9
    nf=225
else if (Lval==4) then
    n1=19
    n2=11
    nf=11025
end if
end subroutine
!!---- Used to produce normalization factor to counteract the contraction coefficient problem of the Molden input file generated by ORCA
!I don't know where the formula comes from
!Lval=0/1/2/3/4 corresponds to s/p/d/f/g

!----- Renormalization of Gauss basis functions for Molden input file
subroutine renormmoldengau(nlen,Lval,exp,con)
implicit real*8 (a-h,o-z)
integer nlen,Lval
real*8 exp(nlen),con(nlen),ctmp(nlen)
pi=acos(-1D0)
call genn1n2nf(Lval,n1,n2,nf)
fc=(2D0**n1)/(pi**3*nf)
do i=1,nlen
    prmnormfac=sqrt(sqrt(fc*(exp(i)**n2)))
    ctmp(i)=con(i)*prmnormfac
end do
facnorm=0D0
do i=1,nlen
    do j=1,i
      expavg=(exp(i)+exp(j))/2D0
      facadd=ctmp(i)*ctmp(j)/sqrt(fc*(expavg**n2))
      if (i/=j) facadd=facadd*2
      facnorm=facnorm+facadd
    end do
end do
if (facnorm>1D-10) facnorm=1/sqrt(facnorm)
con=con*facnorm
end subroutine

!!!------------------------- Generate distance matrix
subroutine gendistmat
use defvar
implicit real*8 (a-h,o-z)
if (allocated(distmat)) deallocate(distmat)
allocate(distmat(ncenter,ncenter))
distmat=0.0D0
do i=1,ncenter
    do j=i+1,ncenter
        distmat(i,j)=dsqrt((a(i)%x-a(j)%x)**2+(a(i)%y-a(j)%y)**2+(a(i)%z-a(j)%z)**2)
    end do
end do
distmat=distmat+transpose(distmat)
end subroutine

!!!------------------ Generate density matrix, can be used when basis function information is available
subroutine genP
use defvar
implicit real*8 (a-h,o-z)
if (allocated(Ptot)) deallocate(Ptot)
if (allocated(Palpha)) deallocate(Palpha)
if (allocated(Pbeta)) deallocate(Pbeta)
allocate(Ptot(nbasis,nbasis))
Ptot=0
if (wfntype==1.or.wfntype==2.or.wfntype==4) then !open-shell
    allocate(Palpha(nbasis,nbasis))
    allocate(Pbeta(nbasis,nbasis))
    Palpha=0D0
    Pbeta=0D0
end if

!For SCF wavefunction, if the wavefunction has not been modified (imodwfn==0), use fast way to construct it
!However, if the wavefunction has been modified, the case may be complicated, for example, there is a hole orbital. In these cases
!We use general way (as used for post-HF) to construct density matrix

if (wfntype==0.and.imodwfn==0) then !RHF
    Ptot=2*matmul(CObasa(:,1:nint(naelec)),transpose(CObasa(:,1:nint(naelec))))
else if (wfntype==1.and.imodwfn==0) then !UHF
    Palpha=matmul(CObasa(:,1:nint(naelec)),transpose(CObasa(:,1:nint(naelec))))
    Pbeta=matmul(CObasb(:,1:nint(nbelec)),transpose(CObasb(:,1:nint(nbelec))))
    Ptot=Palpha+Pbeta
else if (wfntype==2.and.imodwfn==0) then !ROHF
    Palpha=matmul(CObasa(:,1:nint(naelec)),transpose(CObasa(:,1:nint(naelec))))
    Pbeta=matmul(CObasa(:,1:nint(nbelec)),transpose(CObasa(:,1:nint(nbelec))))
    Ptot=Palpha+Pbeta
else if (wfntype==3.or.((wfntype==0.or.wfntype==2).and.imodwfn==1)) then !Restricted post-HF
    do imo=1,nmo
        if (MOocc(imo)==0D0) cycle
        Ptot=Ptot+MOocc(imo)*matmul(CObasa(:,imo:imo),transpose(CObasa(:,imo:imo)))
    end do
else if (wfntype==4.or.(wfntype==1.and.imodwfn==1)) then !Unrestricted post-HF
    do imo=1,nbasis
        if (MOocc(imo)==0D0) cycle
        Palpha=Palpha+MOocc(imo)*matmul(CObasa(:,imo:imo),transpose(CObasa(:,imo:imo)))
    end do
    do imo=1,nbasis
        if (MOocc(imo+nbasis)==0D0) cycle
        Pbeta=Pbeta+MOocc(imo+nbasis)*matmul(CObasb(:,imo:imo),transpose(CObasb(:,imo:imo)))
    end do
    Ptot=Palpha+Pbeta
end if

end subroutine

!!!------------------ Evaluate overlap integral for two unnormalized GTFs, a warpper of doSintactual for simplicity
subroutine genGTFSmat(GTFSmat,nsize)
use defvar
implicit real*8 (a-h,o-z)
integer nsize
real*8 GTFSmat(nsize)
nthreads=getNThreads()
!$OMP PARALLEL DO SHARED(GTFSmat) PRIVATE(ides,iGTF,jGTF) schedule(dynamic) NUM_THREADS(nthreads)
do iGTF=1,nprims
    do jGTF=iGTF,nprims
        ides=jGTF*(jGTF-1)/2+iGTF
        GTFSmat(ides)=doSint(iGTF,jGTF)
    end do
end do
!$OMP END PARALLEL DO
end subroutine

!!!------------------ Generate overlap matrix between all basis functions
!Sbas should be allocated first. The resultant matrix is for Cartesian basis functions, may be converted to spherical-harmonic later
subroutine genSbas
use defvar
implicit real*8 (a-h,o-z)
Sbas=0D0
nthreads=getNThreads()
!$OMP PARALLEL DO SHARED(Sbas) PRIVATE(i,ii,j,jj) schedule(dynamic) NUM_THREADS(nthreads)
do i=1,nbasis
    do j=i,nbasis
        do ii=primstart(i),primend(i)
            do jj=primstart(j),primend(j)
                Sbas(i,j)=Sbas(i,j)+primconnorm(ii)*primconnorm(jj)*doSint(ii,jj)
            end do
        end do
        Sbas(j,i)=Sbas(i,j)
    end do
end do
!$OMP END PARALLEL DO
end subroutine

!!!-------- Evaluate dipole moment integral for two unnormalized GTFs. The negative charge of electron has been considered!
!~p arguments are the shifts of GTF index as doSintactual
!xint/yint/zint correspond to dipole moment integral in X/Y/Z
subroutine dodipoleint(iGTF,jGTF,ix1p,iy1p,iz1p,ix2p,iy2p,iz2p,xint,yint,zint)
use util
use defvar
implicit real*8(a-h,o-z)
real*8 xint,yint,zint
integer iGTF,jGTF,ix1p,iy1p,iz1p,ix2p,iy2p,iz2p
x1=a(b(iGTF)%center)%x
y1=a(b(iGTF)%center)%y
z1=a(b(iGTF)%center)%z
x2=a(b(jGTF)%center)%x
y2=a(b(jGTF)%center)%y
z2=a(b(jGTF)%center)%z
ee1=b(iGTF)%exp
ee2=b(jGTF)%exp
ep=ee1+ee2
sqrtep=dsqrt(ep)
px=(ee1*x1+ee2*x2)/ep
py=(ee1*y1+ee2*y2)/ep
pz=(ee1*z1+ee2*z2)/ep        
expterm=dexp( -ee1*ee2*((x1-x2)**2+(y1-y2)**2+(z1-z2)**2)/ep )
ix1=type2ix(b(iGTF)%functype)+ix1p
iy1=type2iy(b(iGTF)%functype)+iy1p
iz1=type2iz(b(iGTF)%functype)+iz1p
ix2=type2ix(b(jGTF)%functype)+ix2p
iy2=type2iy(b(jGTF)%functype)+iy2p
iz2=type2iz(b(jGTF)%functype)+iz2p
!First, calculate sx,sy,sz as usual as doSint
numx=ceiling( (ix1+ix2+1)/2D0 ) !Need to calculate n points
sx=0.0D0
do i=1,numx
    tmp=Rhm(numx,i)/sqrtep+px
    term1=(tmp-x1)**ix1
    term2=(tmp-x2)**ix2
    sx=sx+Whm(numx,i)*term1*term2
end do
sx=sx/sqrtep
numy=ceiling( (iy1+iy2+1)/2D0 )
sy=0.0D0
do i=1,numy
    tmp=Rhm(numy,i)/sqrtep+py
    term1=(tmp-y1)**iy1
    term2=(tmp-y2)**iy2
    sy=sy+Whm(numy,i)*term1*term2
end do
sy=sy/sqrtep
numz=ceiling( (iz1+iz2+1)/2D0 )
sz=0.0D0
do i=1,numz
    tmp=Rhm(numz,i)/sqrtep+pz
    term1=(tmp-z1)**iz1
    term2=(tmp-z2)**iz2
    sz=sz+Whm(numz,i)*term1*term2
end do
sz=sz/sqrtep
!Second, calculate overlap integral in X,Y,Z directions but with X,Y,Z coordinate variables (relative to the original point of the whole system) to produce sxx,syy,szz
numx=ceiling( (ix1+ix2+2)/2D0 ) !Because X variable is introduced, ix1+ix2+2 is used instead of ix1+ix2+1
sxx=0.0D0
do i=1,numx
    tmp=Rhm(numx,i)/sqrtep+px
    term1=(tmp-x1)**ix1
    term2=(tmp-x2)**ix2
    sxx=sxx+Whm(numx,i)*term1*term2*tmp
end do
sxx=sxx/sqrtep
numy=ceiling( (iy1+iy2+2)/2D0 )
syy=0.0D0
do i=1,numy
    tmp=Rhm(numy,i)/sqrtep+py
    term1=(tmp-y1)**iy1
    term2=(tmp-y2)**iy2
    syy=syy+Whm(numy,i)*term1*term2*tmp
end do
syy=syy/sqrtep
numz=ceiling( (iz1+iz2+2)/2D0 )
szz=0.0D0
do i=1,numz
    tmp=Rhm(numz,i)/sqrtep+pz
    term1=(tmp-z1)**iz1
    term2=(tmp-z2)**iz2
    szz=szz+Whm(numz,i)*term1*term2*tmp
end do
szz=szz/sqrtep

xint=-sxx*sy*sz*expterm
yint=-sx*syy*sz*expterm
zint=-sx*sy*szz*expterm
end subroutine

!!!--------------- Generate dipole moment integral matrix between all GTFs
!nsize should be nprims*(nprims+1)/2
subroutine genGTFDmat(GTFdipmat,nsize)
use defvar
implicit real*8 (a-h,o-z)
integer nsize
real*8 GTFdipmat(3,nsize)
nthreads=getNThreads()
!$OMP PARALLEL DO SHARED(GTFdipmat) PRIVATE(ides,iGTF,jGTF,xdiptmp,ydiptmp,zdiptmp) schedule(dynamic) NUM_THREADS(nthreads)
do iGTF=1,nprims
    do jGTF=iGTF,nprims
        ides=jGTF*(jGTF-1)/2+iGTF
        call dodipoleint(iGTF,jGTF,0,0,0,0,0,0,xdiptmp,ydiptmp,zdiptmp)
        GTFdipmat(1,ides)=xdiptmp
        GTFdipmat(2,ides)=ydiptmp
        GTFdipmat(3,ides)=zdiptmp
    end do
end do
!$OMP END PARALLEL DO
end subroutine

!!!------------------ Generate dipole moment integral matrix between all basis functions
!Dbas should be allocated first. The resultant matrix is for Cartesian basis functions, may be converted to spherical-harmonic later
subroutine genDbas
use defvar
implicit real*8 (a-h,o-z)
Dbas=0D0
nthreads=getNThreads()
!$OMP PARALLEL DO SHARED(Dbas) PRIVATE(i,ii,j,jj,xdiptmp,ydiptmp,zdiptmp) schedule(dynamic) NUM_THREADS(nthreads)
do i=1,nbasis
    do j=i,nbasis
        do ii=primstart(i),primend(i)
            do jj=primstart(j),primend(j)
                call dodipoleint(ii,jj,0,0,0,0,0,0,xdiptmp,ydiptmp,zdiptmp)
                Dbas(1,i,j)=Dbas(1,i,j)+primconnorm(ii)*primconnorm(jj)*xdiptmp
                Dbas(2,i,j)=Dbas(2,i,j)+primconnorm(ii)*primconnorm(jj)*ydiptmp
                Dbas(3,i,j)=Dbas(3,i,j)+primconnorm(ii)*primconnorm(jj)*zdiptmp
            end do
        end do
        Dbas(:,j,i)=Dbas(:,i,j)
    end do
end do
!$OMP END PARALLEL DO
end subroutine

!!!------- Evaluate magnetic integral for two unnormalized GTFs 
!The imaginary sign i is ignored. Note that the negative sign of magnetic operator is not occurred here
!Consult doVelint for the method for evaluation of <a|d/dx|b>, and TCA,6,341 for the formula of magnetic integral
subroutine doMagint(iGTF,jGTF,xcomp,ycomp,zcomp)
use defvar
implicit real*8(a-h,o-z)
integer iGTF,jGTF
real*8 xcomp,ycomp,zcomp,term(4)
ee1=b(iGTF)%exp
ee2=b(jGTF)%exp
ix1=type2ix(b(iGTF)%functype)
iy1=type2iy(b(iGTF)%functype)
iz1=type2iz(b(iGTF)%functype)
ix2=type2ix(b(jGTF)%functype)
iy2=type2iy(b(jGTF)%functype)
iz2=type2iz(b(jGTF)%functype)
term=0
!X component, <a|y*d/dz-z*d/dy|b>. Since <a|d/dz|b>=iz2*<a|b-1z>-2*ee2*<a|b+1z>, the term such as <a|y*d/dz|b> can be evaluated in terms of dipole integrals iz2*<a|y|b-1z>-2*ee2*<a|y|b+1z>
if(iz2>0) term(1)=   iz2*dipintcomp(2,iGTF,jGTF,0,0,0,0,0,-1) !viz. iz2*<a|y|b-1z>
          term(2)=-2*ee2*dipintcomp(2,iGTF,jGTF,0,0,0,0,0, 1)
if(iy2>0) term(3)=  -iy2*dipintcomp(3,iGTF,jGTF,0,0,0,0,-1,0)
          term(4)= 2*ee2*dipintcomp(3,iGTF,jGTF,0,0,0,0, 1,0)
xcomp=-sum(term) !Note that the result of dipintcomp has a negative sign due to the negative charge of electron, so here revise the sign
term=0
!Y component, <a|z*d/dx-x*d/dz|b>
if(ix2>0) term(1)=   ix2*dipintcomp(3,iGTF,jGTF,0,0,0,-1,0,0)
          term(2)=-2*ee2*dipintcomp(3,iGTF,jGTF,0,0,0, 1,0,0)
if(iz2>0) term(3)=  -iz2*dipintcomp(1,iGTF,jGTF,0,0,0,0,0,-1)
          term(4)= 2*ee2*dipintcomp(1,iGTF,jGTF,0,0,0,0,0, 1)
ycomp=-sum(term)
term=0
!Z component, <a|x*d/dy-y*d/dx|b>
if(iy2>0) term(1)=   iy2*dipintcomp(1,iGTF,jGTF,0,0,0,0,-1,0)
          term(2)=-2*ee2*dipintcomp(1,iGTF,jGTF,0,0,0,0, 1,0)
if(ix2>0) term(3)=  -ix2*dipintcomp(2,iGTF,jGTF,0,0,0,-1,0,0)
          term(4)= 2*ee2*dipintcomp(2,iGTF,jGTF,0,0,0, 1,0,0)
zcomp=-sum(term)
end subroutine

!!!--------------- Generate magnetic dipole moment integral matrix between all GTFs
!nsize should be nprims*(nprims+1)/2
!Beware that when using this result, (j,i) element should be set to negative value of (i,j) due to the Hermitean character of this operator!
subroutine genGTFMmat(GTFdipmat,nsize)
use defvar
implicit real*8 (a-h,o-z)
integer nsize
real*8 GTFdipmat(3,nsize)
GTFdipmat=0D0
nthreads=getNThreads()
!$OMP PARALLEL DO SHARED(GTFdipmat) PRIVATE(ides,iGTF,jGTF,xdiptmp,ydiptmp,zdiptmp) schedule(dynamic) NUM_THREADS(nthreads)
do iGTF=1,nprims
    do jGTF=iGTF+1,nprims !For iGTF=jGTF, the value must exactly zero, so don't calculate
        ides=jGTF*(jGTF-1)/2+iGTF
        call doMagint(iGTF,jGTF,xdiptmp,ydiptmp,zdiptmp)
        GTFdipmat(1,ides)=xdiptmp
        GTFdipmat(2,ides)=ydiptmp
        GTFdipmat(3,ides)=zdiptmp
    end do
end do
!$OMP END PARALLEL DO
end subroutine

!!!------------------ Generate magnetic integral matrix between all basis functions
!Magbas should be allocated first. The resultant matrix is for Cartesian basis functions, may be converted to spherical-harmonic later
!Notice that the diagonal element of magnetic integral matrix is zero, and (i,j)=-(j,i) due to Hermitean character
subroutine genMagbas
use defvar
implicit real*8 (a-h,o-z)
Magbas=0D0
nthreads=getNThreads()
!$OMP PARALLEL DO SHARED(Magbas) PRIVATE(i,ii,j,jj,xcomp,ycomp,zcomp) schedule(dynamic) NUM_THREADS(nthreads)
do i=1,nbasis
    do j=i+1,nbasis
        do ii=primstart(i),primend(i)
            do jj=primstart(j),primend(j)
                call doMagint(ii,jj,xcomp,ycomp,zcomp)
                Magbas(1,i,j)=Magbas(1,i,j)+primconnorm(ii)*primconnorm(jj)*xcomp
                Magbas(2,i,j)=Magbas(2,i,j)+primconnorm(ii)*primconnorm(jj)*ycomp
                Magbas(3,i,j)=Magbas(3,i,j)+primconnorm(ii)*primconnorm(jj)*zcomp
            end do
        end do
        Magbas(:,j,i)=-Magbas(:,i,j)
    end do
end do
!$OMP END PARALLEL DO
end subroutine

!!!------- Evaluate velocity integral for two unnormalized GTFs 
!There are three components. e.g. X direction: i<a|d/dx|b>. The imaginary sign i is ignored. Note that the negative sign of momentum operator is not occurred here
!One can consult p97 of Chen's book for the derivative of GTF. Namely <a|d/dx|b>=ix2*<a|b-1x>-2*ee2*<a|b+1x>
subroutine doVelint(iGTF,jGTF,xcomp,ycomp,zcomp)
use defvar
implicit real*8(a-h,o-z)
integer iGTF,jGTF
real*8 xcomp,ycomp,zcomp
ee1=b(iGTF)%exp
ee2=b(jGTF)%exp
ix1=type2ix(b(iGTF)%functype)
iy1=type2iy(b(iGTF)%functype)
iz1=type2iz(b(iGTF)%functype)
ix2=type2ix(b(jGTF)%functype)
iy2=type2iy(b(jGTF)%functype)
iz2=type2iz(b(jGTF)%functype)
term1=0
if(ix2>0) term1=   ix2*doSintactual(iGTF,jGTF,0,0,0,-1,0,0)
          term2=-2*ee2*doSintactual(iGTF,jGTF,0,0,0, 1,0,0)
xcomp=term1+term2
term1=0
if(iy2>0) term1=   iy2*doSintactual(iGTF,jGTF,0,0,0,0,-1,0)
          term2=-2*ee2*doSintactual(iGTF,jGTF,0,0,0,0, 1,0)
ycomp=term1+term2
term1=0
if(iz2>0) term1=   iz2*doSintactual(iGTF,jGTF,0,0,0,0,0,-1)
          term2=-2*ee2*doSintactual(iGTF,jGTF,0,0,0,0,0, 1)
zcomp=term1+term2
end subroutine

!!!--------------- Generate velocity integral matrix between all GTFs
!nsize should be nprims*(nprims+1)/2
!Beware that when using this result, (j,i) element should be set to negative value of (i,j) due to the Hermitean character of this operator!
subroutine genGTFVelmat(GTFVelmat,nsize)
use defvar
implicit real*8 (a-h,o-z)
integer nsize
real*8 GTFVelmat(3,nsize)
nthreads=getNThreads()
!$OMP PARALLEL DO SHARED(GTFVelmat) PRIVATE(ides,iGTF,jGTF,xtmp,ytmp,ztmp) schedule(dynamic) NUM_THREADS(nthreads)
do iGTF=1,nprims
    do jGTF=iGTF,nprims
        ides=jGTF*(jGTF-1)/2+iGTF
        call doVelint(iGTF,jGTF,xtmp,ytmp,ztmp)
        GTFVelmat(1,ides)=xtmp
        GTFVelmat(2,ides)=ytmp
        GTFVelmat(3,ides)=ztmp
    end do
end do
!$OMP END PARALLEL DO
end subroutine

!!!------------------ Generate velocity integral matrix between all basis functions
!Velbas should be allocated first. The resultant matrix is for Cartesian basis functions, may be converted to spherical-harmonic later
!Notice that the diagonal element of velocity integral matrix is zero, and (i,j)=-(j,i) due to Hermitean character
subroutine genVelbas
use defvar
implicit real*8 (a-h,o-z)
Velbas=0D0
nthreads=getNThreads()
!$OMP PARALLEL DO SHARED(Velbas) PRIVATE(i,ii,j,jj,xcomp,ycomp,zcomp) schedule(dynamic) NUM_THREADS(nthreads)
do i=1,nbasis
    do j=i+1,nbasis
        do ii=primstart(i),primend(i)
            do jj=primstart(j),primend(j)
                call doVelint(ii,jj,xcomp,ycomp,zcomp)
                Velbas(1,i,j)=Velbas(1,i,j)+primconnorm(ii)*primconnorm(jj)*xcomp
                Velbas(2,i,j)=Velbas(2,i,j)+primconnorm(ii)*primconnorm(jj)*ycomp
                Velbas(3,i,j)=Velbas(3,i,j)+primconnorm(ii)*primconnorm(jj)*zcomp
            end do
        end do
        Velbas(:,j,i)=-Velbas(:,i,j)
    end do
end do
!$OMP END PARALLEL DO
end subroutine

!!!------------------ Generate kinetic energy matrix between all GTFs
!nsize should be nprims*(nprims+1)/2
subroutine genGTFTmat(GTFTmat,nsize)
use defvar
implicit real*8 (a-h,o-z)
integer nsize
real*8 GTFTmat(nsize)
nthreads=getNThreads()
!$OMP PARALLEL DO SHARED(GTFTmat) PRIVATE(ides,iGTF,jGTF) schedule(dynamic) NUM_THREADS(nthreads)
do iGTF=1,nprims
    do jGTF=iGTF,nprims
        ides=jGTF*(jGTF-1)/2+iGTF
        GTFTmat(ides)=doTint(iGTF,jGTF)
    end do
end do
!$OMP END PARALLEL DO
end subroutine

!!!------------------ Generate kinetic energy matrix between all basis functions
!Tbas should be allocated first. The resultant matrix is for Cartesian basis functions, may be converted to spherical-harmonic later
subroutine genTbas
use defvar
implicit real*8 (a-h,o-z)
Tbas=0D0
nthreads=getNThreads()
!$OMP PARALLEL DO SHARED(Tbas) PRIVATE(i,ii,j,jj) schedule(dynamic) NUM_THREADS(nthreads)
do i=1,nbasis
    do j=i,nbasis
        do ii=primstart(i),primend(i)
            do jj=primstart(j),primend(j)
                Tbas(i,j)=Tbas(i,j)+primconnorm(ii)*primconnorm(jj)*doTint(ii,jj)
            end do
        end do
        Tbas(j,i)=Tbas(i,j)
    end do
end do
!$OMP END PARALLEL DO
end subroutine

!!!------ Show system one-electron properties based on density matrix and integral matrix between basis functions
!The results are correct only when Cartesian basis functions are used
subroutine sys1eprop
use defvar
if (.not.allocated(Sbas)) allocate(Sbas(nbasis,nbasis))
call genSbas
write(*,"(' Total number of electrons:',f16.8)") sum(Ptot*Sbas)
if (.not.allocated(Tbas)) allocate(Tbas(nbasis,nbasis))
call genTbas
write(*,"(' Kinetic energy:',f18.9,' a.u.')") sum(Ptot*Tbas)
if (.not.allocated(Dbas)) allocate(Dbas(3,nbasis,nbasis))
call genDbas
write(*,"(' Electric dipole moment in X/Y/Z:',3f13.7,' a.u.')") sum(Ptot*Dbas(1,:,:)),sum(Ptot*Dbas(2,:,:)),sum(Ptot*Dbas(3,:,:))
if (.not.allocated(Magbas)) allocate(Magbas(3,nbasis,nbasis))
call genMagbas
write(*,"(' Magnetic dipole moment in X/Y/Z:',3f13.7,' a.u.')") sum(Ptot*Magbas(1,:,:)),sum(Ptot*Magbas(2,:,:)),sum(Ptot*Magbas(3,:,:))
if (.not.allocated(Velbas)) allocate(Velbas(3,nbasis,nbasis))
call genVelbas
write(*,"(' Linear momentum in X/Y/Z:       ',3f13.7,' a.u.')") sum(Ptot*Velbas(1,:,:)),sum(Ptot*Velbas(2,:,:)),sum(Ptot*Velbas(3,:,:))
end subroutine

!!-------- Deallocate all arrays about wavefunction except that with _org suffix, to avoid problem when load another file
subroutine dealloall
use defvar
implicit real*8 (a-h,o-z)
if (allocated(a)) deallocate(a)
if (allocated(b)) deallocate(b)
if (allocated(CO)) deallocate(CO)
if (allocated(MOocc)) deallocate(MOocc)
if (allocated(MOsym)) deallocate(MOsym)
if (allocated(MOene)) deallocate(MOene)
if (allocated(MOtype)) deallocate(MOtype)
if (allocated(b_EDF)) then
    deallocate(CO_EDF,b_EDF)
    nEDFprims=0
    nEDFelec=0
end if
!Loaded file contains basis information
if (allocated(shtype)) deallocate(shtype,shcen,shcon,primshexp,primshcoeff,&
basshell,bascen,bastype,basstart,basend,primstart,primend,primconnorm)
if (allocated(CObasa)) deallocate(CObasa)
if (allocated(CObasb)) deallocate(CObasb)
if (allocated(Ptot)) deallocate(Ptot)
if (allocated(Palpha)) deallocate(Palpha)
if (allocated(Pbeta)) deallocate(Pbeta)
if (allocated(Sbas)) deallocate(Sbas)
if (allocated(Dbas)) deallocate(Dbas)
end subroutine

!!--- Generate single-center integration grid for Becke's integration. Not adapted according to element. Return iradcut and gridatm
subroutine gen1cintgrid(gridatm,iradcut)
use defvar
implicit real*8 (a-h,o-z)
integer iradcut
real*8 potx(sphpot),poty(sphpot),potz(sphpot),potw(sphpot)
type(content) gridatm(radpot*sphpot)
call Lebedevgen(sphpot,potx,poty,potz,potw)
iradcut=0 !Before where the radial points will be cut
parm=1D0
do i=1,radpot !Combine spherical point&weights with second kind Gauss-Chebyshev method for radial part
    radx=cos(i*pi/(radpot+1))
    radr=(1+radx)/(1-radx)*parm !Becke transform
    radw=2*pi/(radpot+1)*parm**3 *(1+radx)**2.5D0/(1-radx)**3.5D0 *4*pi
    gridatm( (i-1)*sphpot+1:i*sphpot )%x=radr*potx
    gridatm( (i-1)*sphpot+1:i*sphpot )%y=radr*poty
    gridatm( (i-1)*sphpot+1:i*sphpot )%z=radr*potz
    gridatm( (i-1)*sphpot+1:i*sphpot )%value=radw*potw
    if (radcut/=0D0.and.iradcut==0.and.radr<radcut) iradcut=i-1
end do
end subroutine

!!--- Generate Becke weight for a batch of points around iatm, sharpness parameter=3
!!--- Input: iatm, iradcut, gridatm   Return: beckeweigrid
subroutine gen1cbeckewei(iatm,iradcut,gridatm,beckeweigrid)
use defvar
implicit real*8 (a-h,o-z)
integer iatm,iradcut
real*8 beckeweigrid(radpot*sphpot),smat(ncenter,ncenter),Pvec(ncenter)
type(content) gridatm(radpot*sphpot)
nthreads=getNThreads()
!$OMP parallel do shared(beckeweigrid) private(i,rnowx,rnowy,rnowz,smat,ii,ri,jj,rj,rmiu,chi,uij,aij,tmps,Pvec) num_threads(nthreads) schedule(dynamic)
do i=1+iradcut*sphpot,radpot*sphpot
    smat=1D0
    rnowx=gridatm(i)%x
    rnowy=gridatm(i)%y
    rnowz=gridatm(i)%z
    do ii=1,ncenter
        ri=dsqrt( (rnowx-a(ii)%x)**2+(rnowy-a(ii)%y)**2+(rnowz-a(ii)%z)**2 )
        do jj=1,ncenter
            if (ii==jj) cycle
            rj=dsqrt( (rnowx-a(jj)%x)**2+(rnowy-a(jj)%y)**2+(rnowz-a(jj)%z)**2 )
            rmiu=(ri-rj)/distmat(ii,jj)
             !Adjust for heteronuclear
            chi=covr_tianlu(a(ii)%index)/covr_tianlu(a(jj)%index)
            uij=(chi-1)/(chi+1)
            aij=uij/(uij**2-1)
            if (aij>0.5D0) aij=0.5D0
            if (aij<-0.5D0) aij=-0.5D0
            rmiu=rmiu+aij*(1-rmiu**2)
            tmps=rmiu
            do iter=1,3
                tmps=1.5D0*(tmps)-0.5D0*(tmps)**3
            end do
            smat(ii,jj)=0.5D0*(1-tmps)
        end do
    end do
    Pvec=1D0
    do ii=1,ncenter
        Pvec=Pvec*smat(:,ii)
    end do
    beckeweigrid(i)=Pvec(iatm)/sum(Pvec)
end do
!$OMP end parallel do
end subroutine

!!!------------------- Calculate properties based on atom geometry information
subroutine calcgeomprop
use defvar
use util
implicit real*8 (a-h,o-z)
character c2000tmp*2000
integer,allocatable :: calcatom(:)
do while(.true.)
    write(*,*) "Input the indices of the atoms to be taken into account"
    write(*,*) "e.g. 1,3-6,8,10-11 means the atoms 1,3,4,5,6,8,10,11 will be considered"
    write(*,*) "Input ""all"" can calculate the whole system. Input q can exit"
    read(*,"(a)") c2000tmp
    if (c2000tmp(1:1)=='q'.or.c2000tmp(1:1)=='Q') exit
    if (allocated(calcatom)) deallocate(calcatom)
    if (index(c2000tmp,"all")/=0) then
        ncalcatom=ncenter
        allocate(calcatom(ncalcatom))
        do itmp=1,ncalcatom
            calcatom(itmp)=itmp
        end do
    else
        call str2arr(c2000tmp,ncalcatom)
        allocate(calcatom(ncalcatom))
        call str2arr(c2000tmp,ncalcatom,calcatom)
    end if
    call calcmolinfo(calcatom,ncalcatom)
    write(*,*)
end do
end subroutine

!!----- Show some molecular information based on geometry
!atmarray records which atoms will be taken into account, natmarr elements are there
subroutine calcmolinfo(atmarr,natmarr)
use util
use defvar
implicit real*8 (a-h,o-z)
integer atmarr(natmarr)
real*8 inertia(3,3),eigvalint(3),eigvecmatint(3,3)
totmass=sum(atmwei(a(atmarr(:))%index))
avgx=sum(a(atmarr(:))%x)/natmarr
avgy=sum(a(atmarr(:))%y)/natmarr
avgz=sum(a(atmarr(:))%z)/natmarr
cenmassx=sum(a(atmarr(:))%x*atmwei(a(atmarr(:))%index))/totmass
cenmassy=sum(a(atmarr(:))%y*atmwei(a(atmarr(:))%index))/totmass
cenmassz=sum(a(atmarr(:))%z*atmwei(a(atmarr(:))%index))/totmass
rgyr=dsqrt( sum( atmwei(a(atmarr(:))%index)* ((a(atmarr(:))%x-cenmassx)**2+(a(atmarr(:))%y-cenmassy)**2+(a(atmarr(:))%z-cenmassz)**2) ) / totmass )
totnucchg=sum(a(atmarr(:))%charge)
dipnucx=sum(a(atmarr(:))%x*a(atmarr(:))%charge)
dipnucy=sum(a(atmarr(:))%y*a(atmarr(:))%charge)
dipnucz=sum(a(atmarr(:))%z*a(atmarr(:))%charge)
dipnucnorm=dsqrt(dipnucx**2+dipnucy**2+dipnucz**2)
write(*,"(' Mass of these atoms:',f14.6,' amu')") totmass
write(*,"(' Geometry center (X/Y/Z):',3f14.8,' Angstrom')") avgx*b2a,avgy*b2a,avgz*b2a
write(*,"(' Center of mass (X/Y/Z): ',3f14.8,' Angstrom')") cenmassx*b2a,cenmassy*b2a,cenmassz*b2a
if (ifiletype==4) then !chg file
    write(*,"(' Sum of atomic charges:',f20.8)") totnucchg
    write(*,"(' Dipole from atomic charges (Norm):',E12.5,' a.u.',E13.5,' Debye')") dipnucnorm,dipnucnorm*au2debye
    write(*,"(' Dipole from atomic charges (X/Y/Z):',3E12.5,' a.u.')") dipnucx,dipnucy,dipnucz
else if (ifiletype/=4) then
    write(*,"(' Sum of nuclear charges:',f20.8)") totnucchg
    write(*,"(' Center of nuclear charges (X/Y/Z):',3f13.7,' Ang')") dipnucx*b2a/totnucchg,dipnucy*b2a/totnucchg,dipnucz*b2a/totnucchg
    write(*,"(' Dipole from nuclear charges (Norm):',E12.5,' a.u.',E13.5,' Debye')") dipnucnorm,dipnucnorm*au2debye
    write(*,"(' Dipole from nuclear charges (X/Y/Z):',3E12.5,' a.u.')") dipnucx,dipnucy,dipnucz
end if
write(*,"(' Radius of gyration:',f14.8,' Angstrom')") rgyr*b2a
xmin=a(atmarr(1))%x
ymin=a(atmarr(1))%y
zmin=a(atmarr(1))%z
xmax=xmin
ymax=ymin
zmax=zmin
ixmax=atmarr(1)
iymax=atmarr(1)
izmax=atmarr(1)
ixmin=atmarr(1)
iymin=atmarr(1)
izmin=atmarr(1)
do idx=1,natmarr
    iatm=atmarr(idx)
    if (a(iatm)%x>xmax) then
        xmax=a(iatm)%x
        ixmax=iatm
    end if
    if (a(iatm)%y>ymax) then
        ymax=a(iatm)%y
        iymax=iatm
    end if
    if (a(iatm)%z>zmax) then
        zmax=a(iatm)%z
        izmax=iatm
    end if
    if (a(iatm)%x<xmin) then
        xmin=a(iatm)%x
        ixmin=iatm
    end if
    if (a(iatm)%y<ymin) then
        ymin=a(iatm)%y
        iymin=iatm
    end if
    if (a(iatm)%z<zmin) then
        zmin=a(iatm)%z
        izmin=iatm
    end if
end do
write(*,"(' Minimum X is',f14.8,' Angstrom, at atom',i6,'(',a,')')") xmin,ixmin,a(ixmin)%name
write(*,"(' Minimum Y is',f14.8,' Angstrom, at atom',i6,'(',a,')')") ymin,iymin,a(iymin)%name
write(*,"(' Minimum Z is',f14.8,' Angstrom, at atom',i6,'(',a,')')") zmin,izmin,a(izmin)%name
write(*,"(' Maximum X is',f14.8,' Angstrom, at atom',i6,'(',a,')')") xmax,ixmax,a(ixmax)%name
write(*,"(' Maximum Y is',f14.8,' Angstrom, at atom',i6,'(',a,')')") ymax,iymax,a(iymax)%name
write(*,"(' Maximum Z is',f14.8,' Angstrom, at atom',i6,'(',a,')')") zmax,izmax,a(izmax)%name
if (natmarr>=2) then
    rmindist=1D50
    rmaxdist=0
    do iidx=1,natmarr
        i=atmarr(iidx)
        do jidx=iidx+1,natmarr
            j=atmarr(jidx)
            if (distmat(i,j)<rmindist) then
                rmindist=distmat(i,j)
                imindist=i
                jmindist=j
            end if
            if (distmat(i,j)>rmaxdist) then
                rmaxdist=distmat(i,j)
                imaxdist=i
                jmaxdist=j
            end if
        end do
    end do
    write(*,"(' Maximum distance is',f12.6,' Angstrom, between atom',i6,'(',a,') and',i6,'(',a,')')") rmaxdist*b2a,imaxdist,a(imaxdist)%name,jmaxdist,a(jmaxdist)%name
    write(*,"(' Minimum distance is',f12.6,' Angstrom, between atom',i6,'(',a,') and',i6,'(',a,')')") rmindist*b2a,imindist,a(imindist)%name,jmindist,a(jmindist)%name
end if
do iatmidx=1,natmarr
    iatm=atmarr(iatmidx)
    disttmp=dsqrt((avgx-a(iatm)%x)**2+(avgy-a(iatm)%y)**2+(avgz-a(iatm)%z)**2)
    if (iatmidx==1.or.disttmp>distmax) then
        distmax=disttmp
        idistmax=iatm
    end if
    if (iatmidx==1.or.disttmp<distmin) then
        distmin=disttmp
        idistmin=iatm
    end if
end do
write(*,"(' The atom closest to geometry center is',i8,'(',a,')  Dist:',f12.6,' Angstrom')") idistmin,a(idistmin)%name,distmin*b2a
write(*,"(' The atom farthest to geometry center is',i7,'(',a,')  Dist:',f12.6,' Angstrom')") idistmax,a(idistmax)%name,distmax*b2a
write(*,*)
inertia(1,1)=sum(atmwei(a(atmarr(:))%index)*( (a(atmarr(:))%y-cenmassy)**2+(a(atmarr(:))%z-cenmassz)**2) )*b2a*b2a
inertia(2,2)=sum(atmwei(a(atmarr(:))%index)*( (a(atmarr(:))%x-cenmassx)**2+(a(atmarr(:))%z-cenmassz)**2) )*b2a*b2a
inertia(3,3)=sum(atmwei(a(atmarr(:))%index)*( (a(atmarr(:))%x-cenmassx)**2+(a(atmarr(:))%y-cenmassy)**2) )*b2a*b2a
inertia(1,2)=-sum(atmwei(a(atmarr(:))%index)*(a(atmarr(:))%x-cenmassx)*(a(atmarr(:))%y-cenmassy))*b2a*b2a
inertia(2,1)=inertia(1,2)
inertia(1,3)=-sum(atmwei(a(atmarr(:))%index)*(a(atmarr(:))%x-cenmassx)*(a(atmarr(:))%z-cenmassz))*b2a*b2a
inertia(3,1)=inertia(1,3)
inertia(2,3)=-sum(atmwei(a(atmarr(:))%index)*(a(atmarr(:))%y-cenmassy)*(a(atmarr(:))%z-cenmassz))*b2a*b2a
inertia(3,2)=inertia(2,3)
call showmatgau(inertia,"Moments of inertia tensor (amu*Angstrom^2)")
write(*,"(' The moments of inertia relative to X,Y,Z axes (amu*Angstrom^2):',/,3E16.8)") inertia(1,1),inertia(2,2),inertia(3,3)
rotcstA=planckc/(8D0*pi**2*inertia(1,1)*amu2kg*1D-20)/1D9 !1D-20 used to convert Angstrom to meter, GHz=1D9Hz, 1Hz=1/s
rotcstB=planckc/(8D0*pi**2*inertia(2,2)*amu2kg*1D-20)/1D9
rotcstC=planckc/(8D0*pi**2*inertia(3,3)*amu2kg*1D-20)/1D9
write(*,"(' Rotational constant relative to X,Y,Z axes (GHz):',/,3f16.8)") rotcstA,rotcstB,rotcstC
call diagmat(inertia,eigvecmatint,eigvalint,300,1D-12)
call showmatgau(eigvecmatint,"Principal axes (each column vector)")
write(*,"(' The moments of inertia relative to principal axes (amu*Angstrom^2): ',/,3E16.8)") eigvalint
write(*,"(' Rotational constant relative to principal axes (GHz):',/,3f16.8)") planckc/(8D0*pi**2*eigvalint(1:3)*amu2kg*1D-20)/1D9
end subroutine

! The following is kept in here for future usage with B13 (eventually)
! -=Warning=- remember to include also atmraddens.f90 to calculate Hirshfeld charges
!
!!!------- Generate atomic/fragmental Hirshfeld weight and store it to planemat, calculate free-atom/fragmental density and store it to planemattmp
!!The atoms in the fragment is inputted as "selatm" array, nselatm is the number of its elements
!!if itype=1, use atomic wavefunction to calculate Hirshfeld weight, and setpromol must have been invoked; if =2, use built-in atomic density to generate it
!subroutine genHirshplanewei(selatm,nselatm,itype)
!use defvar
!use function
!implicit real*8 (a-h,o-z)
!integer selatm(nselatm),nselatm,itype
!if (allocated(planemat)) deallocate(planemat)
!if (allocated(planemattmp)) deallocate(planemattmp)
!allocate(planemat(ngridnum1,ngridnum2),planemattmp(ngridnum1,ngridnum2))
!planemat=0D0
!planemattmp=0D0
!do iatm=1,ncenter_org !Calc free atomic density of each atom, get promolecular density and Hirshfeld weight of present atom
!    iyes=0
!    if (any(selatm==iatm)) iyes=1
!    if (itype==1) then
!        call dealloall
!        call readwfn(custommapname(iatm),1)
!    end if
!nthreads=getNThreads()
!!$OMP PARALLEL DO private(i,j,rnowx,rnowy,rnowz,tmpval) shared(planemat) schedule(dynamic) NUM_THREADS(nthreads)
!    do i=1,ngridnum1 !First calculate promolecular density and store it to planemat
!        do j=1,ngridnum2
!            rnowx=orgx2D+(i-1)*v1x+(j-1)*v2x
!            rnowy=orgy2D+(i-1)*v1y+(j-1)*v2y
!            rnowz=orgz2D+(i-1)*v1z+(j-1)*v2z
!            if (itype==1) then
!                tmpval=fdens(rnowx,rnowy,rnowz)
!            else
!                tmpval=calcatmdens(iatm,rnowx,rnowy,rnowz,0)
!            end if
!            planemat(i,j)=planemat(i,j)+tmpval
!            if (iyes==1) planemattmp(i,j)=planemattmp(i,j)+tmpval
!        end do
!    end do
!!$OMP END PARALLEL DO
!end do
!if (itype==1) then
!    call dealloall
!    call readinfile(firstfilename,1) !Retrieve the first loaded file(whole molecule)
!end if
!
!do i=1,ngridnum1 !Calculate Hirshfeld weighting function
!    do j=1,ngridnum2
!        if (planemat(i,j)/=0D0) then
!            planemat(i,j)=planemattmp(i,j)/planemat(i,j)
!        else
!            planemat(i,j)=0D0
!        end if
!    end do
!end do
!end subroutine
!


!!!----- Generate atomic Hirshfeld weight and store it to cubmat
!!The atoms in the fragment is inputted as "selatm" array, nselatm is the number of its elements
!!if itype=1, use atomic wavefunction to calculate Hirshfeld weight, and setpromol must have been invoked; if =2, use built-in atomic density to generate it
!subroutine genHirshcubewei(selatm,nselatm,itype)
!use defvar
!use function
!implicit real*8 (a-h,o-z)
!integer selatm(nselatm),nselatm,itype
!if (allocated(cubmat)) deallocate(cubmat)
!if (allocated(cubmattmp)) deallocate(cubmattmp)
!allocate(cubmat(nx,ny,nz),cubmattmp(nx,ny,nz))
!cubmat=0D0
!cubmattmp=0D0
!do iatm=1,ncenter_org
!    write(*,"(' Finished',i6,'  /',i6)") iatm,ncenter_org
!    if (itype==1) then
!        call dealloall
!        call readwfn(custommapname(iatm),1)
!    end if
!nthreads=getNThreads()
!!$OMP PARALLEL DO SHARED(cubmat,cubmattmp,ifinish) PRIVATE(i,j,k,tmpx,tmpy,tmpz,tmpval) schedule(dynamic) NUM_THREADS(nthreads)
!    do k=1,nz !First calculate promolecular density and store it to cubmat
!        tmpz=orgz+(k-1)*dz
!        do j=1,ny
!            tmpy=orgy+(j-1)*dy
!            do i=1,nx
!                tmpx=orgx+(i-1)*dx
!                if (itype==1) then
!                    tmpval=fdens(tmpx,tmpy,tmpz)
!                else
!                    tmpval=calcatmdens(iatm,tmpx,tmpy,tmpz,0)
!                end if
!                cubmat(i,j,k)=cubmat(i,j,k)+tmpval
!                if (any(selatm==iatm)) cubmattmp(i,j,k)=cubmattmp(i,j,k)+tmpval
!            end do
!        end do
!    end do
!!$OMP END PARALLEL DO
!end do
!if (itype==1) then
!    call dealloall
!    call readinfile(firstfilename,1) !Retrieve the first loaded file(whole molecule)
!end if
!
!do k=1,nz !Calculate Hirshfeld weighting function
!    do j=1,ny
!        do i=1,nx
!            if (cubmat(i,j,k)/=0D0) then
!                cubmat(i,j,k)=cubmattmp(i,j,k)/cubmat(i,j,k)
!            else
!                cubmat(i,j,k)=0D0
!            end if
!        end do
!    end do
!end do
!end subroutine
!
!
!
!!!----------- Output spherically averaged atomic radial density, then used for generating promolecular density for heavy atoms
!subroutine sphatmraddens
!use defvar
!use function
!implicit real*8 (a-h,o-z)
!real*8,allocatable :: potx(:),poty(:),potz(:),potw(:),radpos(:),sphavgval(:)
!truncrho=1D-8
!rlow=0D0
!rhigh=12
!nsphpt=2030
!nradpt=200 !Totally 200 radial points, but the number of point is truncated at truncrho
!allocate(potx(nsphpt),poty(nsphpt),potz(nsphpt),potw(nsphpt),radpos(nradpt),sphavgval(nradpt))
!call Lebedevgen(nsphpt,potx,poty,potz,potw)
!ifinish=0
!iprogstp=20
!iprogcrit=iprogstp
!write(*,*) "Calculating..."
!nthreads=getNThreads()
!!$OMP PARALLEL DO SHARED(sphavgval,radpos,ifinish,iprogcrit) PRIVATE(irad,radx,radr,isph,rnowx,rnowy,rnowz,tmpval) schedule(dynamic) NUM_THREADS(nthreads)
!do irad=1,nradpt
!    radx=cos(irad*pi/(nradpt+1))
!    radr=(1+radx)/(1-radx) !Becke transform
!    radpos(irad)=radr
!    tmpval=0
!    do isph=1,nsphpt
!        rnowx=potx(isph)*radr
!        rnowy=poty(isph)*radr
!        rnowz=potz(isph)*radr
!        tmpval=tmpval+fdens(rnowx,rnowy,rnowz)*potw(isph)
!    end do
!    sphavgval(irad)=tmpval !Spherically average density
!    ifinish=ifinish+1
!    if (ifinish==iprogcrit) then
!        write(*,"(' Finished:',i6,'  /',i6)") ifinish,nradpt
!        iprogcrit=iprogcrit+iprogstp
!    end if
!end do
!!$OMP END PARALLEL DO
!open(10,file="sphavgval.txt",status="replace")
!itmp=0
!do irad=nradpt,1,-1
!    if (sphavgval(irad)>truncrho) itmp=itmp+1
!end do
!write(10,"(a,i3,a)") "else if (iele==",a(1)%index,") then  !"
!write(10,"('    npt=',i5)") itmp
!itmp=0
!do irad=nradpt,1,-1
!    if (sphavgval(irad)>truncrho) then
!        itmp=itmp+1
!        write(10,"('    rhoarr(',i3,')=',f25.10,'D0')") itmp,sphavgval(irad)
!    end if
!end do
!close(10)
!write(*,*) "The result has been output to sphavgval.txt in current folder"
!write(*,*) "The second column is radial distance (Bohr), the third column is value"
!end subroutine

!!!--------- Lagrange interpolation in 1D, produce interpolated value, 1st and 2nd derivatives
!!NOTE: 4 adjacent data points will be used to interpolate
!!ptpos and ptval are the position and value of the input array, npt is the number of its element. ptpos must vary from small to large
!!r is the point to be studied, the resultant val, der1, der2 are its value, 1st and 2nd derivatives
!!itype=1: only calculate value    =2: also calculate 1st-derv.    =3: also calculate 2nd-derv.
!subroutine lagintpol(ptpos,ptval,npt,r,val,der1,der2,itype)
!implicit real*8(a-h,o-z)
!integer npt,itype
!real*8 ptpos(npt),ptval(npt),r,val,der1,der2
!if (r<=ptpos(1)) then !Out of boundary
!    der1=(ptval(2)-ptval(1))/(ptpos(2)-ptpos(1))
!    der2=0D0
!    val=ptval(1)-(ptpos(1)-r)*der1 !Use linear interpolation
!    return
!else if (r>=ptpos(npt)) then
!    val=0D0 !Because this function is mainly used to interpolate radial atomic density, at long distance the value must be zero
!    der1=0D0
!    der2=0D0
!!     val=ptval(npt)
!!     der1=(ptval(npt)-ptval(npt-1))/(ptpos(npt)-ptpos(npt-1))
!     return
!end if
!do i=1,npt !Determine which four data points will be used to interpolation
!    if (ptpos(i)>r) exit
!end do
!! if (i==npt+1) i=npt !i==npt+1 means i exceeded the last point
!iend=i+1
!istart=i-2
!if (istart<1) then
!    istart=istart+1
!    iend=iend+1
!else if (iend>npt) then
!    iend=iend-1
!    istart=istart-1
!end if
!!Calculate interpolated value
!val=0D0
!do m=istart,iend
!    poly=1D0
!    do j=istart,iend
!        if (j==m) cycle
!        poly=poly* (r-ptpos(j))/(ptpos(m)-ptpos(j))
!    end do
!    val=val+ptval(m)*poly
!end do
!!Calculate interpolated 1st-derv.
!if (itype<2) return
!der1=0D0
!do m=istart,iend
!    suml=0D0
!    do l=istart,iend
!        if (l==m) cycle
!        poly=1D0
!        do j=istart,iend
!            if (j==m.or.j==l) cycle
!            poly=poly* (r-ptpos(j))/(ptpos(m)-ptpos(j))
!        end do
!        suml=suml+poly/(ptpos(m)-ptpos(l))
!    end do
!    der1=der1+ptval(m)*suml
!end do
!!Calculate interpolated 2nd-derv.
!if (itype<3) return
!der2=0D0
!do m=istart,iend
!    suml=0D0
!    do l=istart,iend
!        if (l==m) cycle
!        sumn=0D0
!        do n=istart,iend
!            if (n==l.or.n==m) cycle
!            poly=1D0
!            do j=istart,iend
!                if (j==l.or.j==m.or.j==n) cycle
!                poly=poly* (r-ptpos(j))/(ptpos(m)-ptpos(j))
!            end do
!            sumn=sumn+poly/(ptpos(m)-ptpos(n))
!        end do
!        suml=suml+sumn/(ptpos(m)-ptpos(l))
!    end do
!    der2=der2+ptval(m)*suml
!end do
!end subroutine
!
!
!

